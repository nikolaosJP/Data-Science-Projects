{"version":3,"sources":["../../src/immer.ts","../../src/utils/env.ts","../../src/utils/errors.ts","../../src/utils/common.ts","../../src/utils/plugins.ts","../../src/core/scope.ts","../../src/core/finalize.ts","../../src/core/proxy.ts","../../src/core/immerClass.ts","../../src/core/current.ts","../../src/plugins/patches.ts","../../src/plugins/mapset.ts"],"sourcesContent":["import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = /* @__PURE__ */ immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(\n\timmer\n)\n\n/**\n * Pass false to use loose iteration that only processes enumerable string properties.\n * This skips symbols and non-enumerable properties for maximum performance.\n *\n * By default, strict iteration is enabled (includes all own properties).\n */\nexport const setUseStrictIteration = /* @__PURE__ */ immer.setUseStrictIteration.bind(\n\timmer\n)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = /* @__PURE__ */ immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport let castDraft = <T>(value: T): Draft<T> => value as any\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport let castImmutable = <T>(value: T): Immutable<T> => value as any\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n","// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n","import {isFunction} from \"../internal\"\n\nexport const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = isFunction(e) ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n","import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nconst O = Object\n\nexport const getPrototypeOf = O.getPrototypeOf\n\nexport const CONSTRUCTOR = \"constructor\"\nexport const PROTOTYPE = \"prototype\"\n\nexport const CONFIGURABLE = \"configurable\"\nexport const ENUMERABLE = \"enumerable\"\nexport const WRITABLE = \"writable\"\nexport const VALUE = \"value\"\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport let isDraft = (value: any): boolean => !!value && !!value[DRAFT_STATE]\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tisArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value[CONSTRUCTOR]?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = O[PROTOTYPE][CONSTRUCTOR].toString()\nconst cachedCtorStrings = new WeakMap()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || !isObjectish(value)) return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null || proto === O[PROTOTYPE]) return true\n\n\tconst Ctor = O.hasOwnProperty.call(proto, CONSTRUCTOR) && proto[CONSTRUCTOR]\n\tif (Ctor === Object) return true\n\n\tif (!isFunction(Ctor)) return false\n\n\tlet ctorString = cachedCtorStrings.get(Ctor)\n\tif (ctorString === undefined) {\n\t\tctorString = Function.toString.call(Ctor)\n\t\tcachedCtorStrings.set(Ctor, ctorString)\n\t}\n\n\treturn ctorString === objectCtorString\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n *\n * @param obj The object to iterate over\n * @param iter The iterator function\n * @param strict When true (default), includes symbols and non-enumerable properties.\n *               When false, uses looseiteration over only enumerable string properties.\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void,\n\tstrict?: boolean\n): void\nexport function each(obj: any, iter: any, strict: boolean = true) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\t// If strict, we do a full iteration including symbols and non-enumerable properties\n\t\t// Otherwise, we only iterate enumerable string properties for performance\n\t\tconst keys = strict ? Reflect.ownKeys(obj) : O.keys(obj)\n\t\tkeys.forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport let has = (\n\tthing: any,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): boolean =>\n\ttype === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: O[PROTOTYPE].hasOwnProperty.call(thing, prop)\n\n/*#__PURE__*/\nexport let get = (\n\tthing: AnyMap | AnyObject,\n\tprop: PropertyKey,\n\ttype = getArchtype(thing)\n): any =>\n\t// @ts-ignore\n\ttype === ArchType.Map ? thing.get(prop) : thing[prop]\n\n/*#__PURE__*/\nexport let set = (\n\tthing: any,\n\tpropOrOldValue: PropertyKey,\n\tvalue: any,\n\ttype = getArchtype(thing)\n) => {\n\tif (type === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (type === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\nexport let isArray = Array.isArray\n\n/*#__PURE__*/\nexport let isMap = (target: any): target is AnyMap => target instanceof Map\n\n/*#__PURE__*/\nexport let isSet = (target: any): target is AnySet => target instanceof Set\n\nexport let isObjectish = (target: any) => typeof target === \"object\"\n\nexport let isFunction = (target: any): target is Function =>\n\ttypeof target === \"function\"\n\nexport let isBoolean = (target: any): target is boolean =>\n\ttypeof target === \"boolean\"\n\nexport let getProxyDraft = <T extends any>(value: T): ImmerState | null => {\n\tif (!isObjectish(value)) return null\n\treturn (value as {[DRAFT_STATE]: any})?.[DRAFT_STATE]\n}\n\n/*#__PURE__*/\nexport let latest = (state: ImmerState): any => state.copy_ || state.base_\n\nexport let getValue = <T extends object>(value: T): T => {\n\tconst proxyDraft = getProxyDraft(value)\n\treturn proxyDraft ? proxyDraft.copy_ ?? proxyDraft.base_ : value\n}\n\nexport let getFinalValue = (state: ImmerState): any =>\n\tstate.modified_ ? state.copy_ : state.base_\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (isArray(base)) return Array[PROTOTYPE].slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = O.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc[WRITABLE] === false) {\n\t\t\t\tdesc[WRITABLE] = true\n\t\t\t\tdesc[CONFIGURABLE] = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\t[CONFIGURABLE]: true,\n\t\t\t\t\t[WRITABLE]: true, // could live with !!desc.set as well here...\n\t\t\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t\t\t[VALUE]: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn O.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = O.create(proto)\n\t\treturn O.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\tO.defineProperties(obj, {\n\t\t\tset: dontMutateMethodOverride,\n\t\t\tadd: dontMutateMethodOverride,\n\t\t\tclear: dontMutateMethodOverride,\n\t\t\tdelete: dontMutateMethodOverride\n\t\t})\n\t}\n\tO.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.values (only string-like, enumerables) instead of each()\n\t\teach(\n\t\t\tobj,\n\t\t\t(_key, value) => {\n\t\t\t\tfreeze(value, true)\n\t\t\t},\n\t\t\tfalse\n\t\t)\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nconst dontMutateMethodOverride = {\n\t[VALUE]: dontMutateFrozenCollections\n}\n\nexport function isFrozen(obj: any): boolean {\n\t// Fast path: primitives and null/undefined are always \"frozen\"\n\tif (obj === null || !isObjectish(obj)) return true\n\treturn O.isFrozen(obj)\n}\n","import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie,\n\tImmerScope\n} from \"../internal\"\n\nexport const PluginMapSet = \"MapSet\"\nexport const PluginPatches = \"Patches\"\n\nexport type PatchesPlugin = {\n\tgeneratePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\trootScope: ImmerScope\n\t): void\n\tgenerateReplacementPatches_(\n\t\tbase: any,\n\t\treplacement: any,\n\t\trootScope: ImmerScope\n\t): void\n\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\tgetPath: (state: ImmerState) => PatchPath | null\n}\n\nexport type MapSetPlugin = {\n\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): [T, ImmerState]\n\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): [T, ImmerState]\n\tfixSetContents: (state: ImmerState) => void\n}\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: PatchesPlugin\n\tMapSet?: MapSetPlugin\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport let isPluginLoaded = <K extends keyof Plugins>(pluginKey: K): boolean =>\n\t!!plugins[pluginKey]\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n","import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin,\n\tPatchesPlugin,\n\tMapSetPlugin,\n\tisPluginLoaded,\n\tPluginMapSet,\n\tPluginPatches\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tpatchPlugin_?: PatchesPlugin\n\tmapSetPlugin_?: MapSetPlugin\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n\thandledSet_: Set<any>\n\tprocessedForPatches_: Set<any>\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport let getCurrentScope = () => currentScope!\n\nlet createScope = (\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope => ({\n\tdrafts_: [],\n\tparent_,\n\timmer_,\n\t// Whenever the modified draft contains a draft from another scope, we\n\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\tcanAutoFreeze_: true,\n\tunfinalizedDrafts_: 0,\n\thandledSet_: new Set(),\n\tprocessedForPatches_: new Set(),\n\tmapSetPlugin_: isPluginLoaded(PluginMapSet)\n\t\t? getPlugin(PluginMapSet)\n\t\t: undefined\n})\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tscope.patchPlugin_ = getPlugin(PluginPatches) // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport let enterScope = (immer: Immer) =>\n\t(currentScope = createScope(currentScope, immer))\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n","import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tget,\n\tPatch,\n\tlatest,\n\tprepareCopy,\n\tgetFinalValue,\n\tgetValue\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t}\n\t\tconst {patchPlugin_} = scope\n\t\tif (patchPlugin_) {\n\t\t\tpatchPlugin_.generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft)\n\t}\n\n\tmaybeFreeze(scope, result, true)\n\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\tif (!state) {\n\t\tconst finalValue = handleValue(value, rootScope.handledSet_, rootScope)\n\t\treturn finalValue\n\t}\n\n\t// Never finalize drafts owned by another scope\n\tif (!isSameScope(state, rootScope)) {\n\t\treturn value\n\t}\n\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\treturn state.base_\n\t}\n\n\tif (!state.finalized_) {\n\t\t// Execute all registered draft finalization callbacks\n\t\tconst {callbacks_} = state\n\t\tif (callbacks_) {\n\t\t\twhile (callbacks_.length > 0) {\n\t\t\t\tconst callback = callbacks_.pop()!\n\t\t\t\tcallback(rootScope)\n\t\t\t}\n\t\t}\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t}\n\n\t// By now the root copy has been fully updated throughout its tree\n\treturn state.copy_\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n\nfunction markStateFinalized(state: ImmerState) {\n\tstate.finalized_ = true\n\tstate.scope_.unfinalizedDrafts_--\n}\n\nlet isSameScope = (state: ImmerState, rootScope: ImmerScope) =>\n\tstate.scope_ === rootScope\n\n// A reusable empty array to avoid allocations\nconst EMPTY_LOCATIONS_RESULT: (string | symbol | number)[] = []\n\n// Updates all references to a draft in its parent to the finalized value.\n// This handles cases where the same draft appears multiple times in the parent, or has been moved around.\nexport function updateDraftInParent(\n\tparent: ImmerState,\n\tdraftValue: any,\n\tfinalizedValue: any,\n\toriginalKey?: string | number | symbol\n): void {\n\tconst parentCopy = latest(parent)\n\tconst parentType = parent.type_\n\n\t// Fast path: Check if draft is still at original key\n\tif (originalKey !== undefined) {\n\t\tconst currentValue = get(parentCopy, originalKey, parentType)\n\t\tif (currentValue === draftValue) {\n\t\t\t// Still at original location, just update it\n\t\t\tset(parentCopy, originalKey, finalizedValue, parentType)\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Slow path: Build reverse mapping of all children\n\t// to their indices in the parent, so that we can\n\t// replace all locations where this draft appears.\n\t// We only have to build this once per parent.\n\tif (!parent.draftLocations_) {\n\t\tconst draftLocations = (parent.draftLocations_ = new Map())\n\n\t\t// Use `each` which works on Arrays, Maps, and Objects\n\t\teach(parentCopy, (key, value) => {\n\t\t\tif (isDraft(value)) {\n\t\t\t\tconst keys = draftLocations.get(value) || []\n\t\t\t\tkeys.push(key)\n\t\t\t\tdraftLocations.set(value, keys)\n\t\t\t}\n\t\t})\n\t}\n\n\t// Look up all locations where this draft appears\n\tconst locations =\n\t\tparent.draftLocations_.get(draftValue) ?? EMPTY_LOCATIONS_RESULT\n\n\t// Update all locations\n\tfor (const location of locations) {\n\t\tset(parentCopy, location, finalizedValue, parentType)\n\t}\n}\n\n// Register a callback to finalize a child draft when the parent draft is finalized.\n// This assumes there is a parent -> child relationship between the two drafts,\n// and we have a key to locate the child in the parent.\nexport function registerChildFinalizationCallback(\n\tparent: ImmerState,\n\tchild: ImmerState,\n\tkey: string | number | symbol\n) {\n\tparent.callbacks_.push(function childCleanup(rootScope) {\n\t\tconst state: ImmerState = child\n\n\t\t// Can only continue if this is a draft owned by this scope\n\t\tif (!state || !isSameScope(state, rootScope)) {\n\t\t\treturn\n\t\t}\n\n\t\t// Handle potential set value finalization first\n\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t// Update all locations in the parent that referenced this draft\n\t\tupdateDraftInParent(parent, state.draft_ ?? state, finalizedValue, key)\n\n\t\tgeneratePatchesAndFinalize(state, rootScope)\n\t})\n}\n\nfunction generatePatchesAndFinalize(state: ImmerState, rootScope: ImmerScope) {\n\tconst shouldFinalize =\n\t\tstate.modified_ &&\n\t\t!state.finalized_ &&\n\t\t(state.type_ === ArchType.Set || (state.assigned_?.size ?? 0) > 0)\n\n\tif (shouldFinalize) {\n\t\tconst {patchPlugin_} = rootScope\n\t\tif (patchPlugin_) {\n\t\t\tconst basePath = patchPlugin_!.getPath(state)\n\n\t\t\tif (basePath) {\n\t\t\t\tpatchPlugin_!.generatePatches_(state, basePath, rootScope)\n\t\t\t}\n\t\t}\n\n\t\tmarkStateFinalized(state)\n\t}\n}\n\nexport function handleCrossReference(\n\ttarget: ImmerState,\n\tkey: string | number | symbol,\n\tvalue: any\n) {\n\tconst {scope_} = target\n\t// Check if value is a draft from this scope\n\tif (isDraft(value)) {\n\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\tif (isSameScope(state, scope_)) {\n\t\t\t// Register callback to update this location when the draft finalizes\n\n\t\t\tstate.callbacks_.push(function crossReferenceCleanup() {\n\t\t\t\t// Update the target location with finalized value\n\t\t\t\tprepareCopy(target)\n\n\t\t\t\tconst finalizedValue = getFinalValue(state)\n\n\t\t\t\tupdateDraftInParent(target, value, finalizedValue, key)\n\t\t\t})\n\t\t}\n\t} else if (isDraftable(value)) {\n\t\t// Handle non-draft objects that might contain drafts\n\t\ttarget.callbacks_.push(function nestedDraftCleanup() {\n\t\t\tconst targetCopy = latest(target)\n\n\t\t\tif (get(targetCopy, key, target.type_) === value) {\n\t\t\t\t// Process the value to replace any nested drafts\n\t\t\t\t// finalizeAssigned(target, key, target.scope_)\n\n\t\t\t\tif (\n\t\t\t\t\tscope_.drafts_.length > 1 &&\n\t\t\t\t\t((target as Exclude<ImmerState, SetState>).assigned_!.get(key) ??\n\t\t\t\t\t\tfalse) === true &&\n\t\t\t\t\ttarget.copy_\n\t\t\t\t) {\n\t\t\t\t\t// This might be a non-draft value that has drafts\n\t\t\t\t\t// inside. We do need to recurse here to handle those.\n\t\t\t\t\thandleValue(\n\t\t\t\t\t\tget(target.copy_, key, target.type_),\n\t\t\t\t\t\tscope_.handledSet_,\n\t\t\t\t\t\tscope_\n\t\t\t\t\t)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t}\n}\n\nexport function handleValue(\n\ttarget: any,\n\thandledSet: Set<any>,\n\trootScope: ImmerScope\n) {\n\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t// This benefits especially adding large data tree's without further processing.\n\t\t// See add-data.js perf test\n\t\treturn target\n\t}\n\n\t// Skip if already handled, frozen, or not draftable\n\tif (\n\t\tisDraft(target) ||\n\t\thandledSet.has(target) ||\n\t\t!isDraftable(target) ||\n\t\tisFrozen(target)\n\t) {\n\t\treturn target\n\t}\n\n\thandledSet.add(target)\n\n\t// Process ALL properties/entries\n\teach(target, (key, value) => {\n\t\tif (isDraft(value)) {\n\t\t\tconst state: ImmerState = value[DRAFT_STATE]\n\t\t\tif (isSameScope(state, rootScope)) {\n\t\t\t\t// Replace draft with finalized value\n\n\t\t\t\tconst updatedValue = getFinalValue(state)\n\n\t\t\t\tset(target, key, updatedValue, target.type_)\n\n\t\t\t\tmarkStateFinalized(state)\n\t\t\t}\n\t\t} else if (isDraftable(value)) {\n\t\t\t// Recursively handle nested values\n\t\t\thandleValue(value, handledSet, rootScope)\n\t\t}\n\t})\n\n\treturn target\n}\n","import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope,\n\thandleCrossReference,\n\tWRITABLE,\n\tCONFIGURABLE,\n\tENUMERABLE,\n\tVALUE,\n\tisArray\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): [Drafted<T, ProxyState>, ProxyState] {\n\tconst baseIsArray = isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: baseIsArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\t// actually instantiated in `prepareCopy()`\n\t\tassigned_: undefined,\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false,\n\t\t// `callbacks` actually gets assigned in `createProxy`\n\t\tcallbacks_: undefined as any\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (baseIsArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn [proxy as any, state]\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop, state.type_)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\t// Ensure array keys are always numbers\n\t\t\tconst childKey = state.type_ === ArchType.Array ? +(prop as string) : prop\n\t\t\tconst childDraft = createProxy(state.scope_, value, state, childKey)\n\n\t\t\treturn (state.copy_![childKey] = childDraft)\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_!.set(prop, false)\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (\n\t\t\t\tis(value, current) &&\n\t\t\t\t(value !== undefined || has(state.base_, prop, state.type_))\n\t\t\t)\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_!.set(prop, true)\n\n\t\thandleCrossReference(state, prop, value)\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\tprepareCopy(state)\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_!.set(prop, false)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tstate.assigned_!.delete(prop)\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\t[WRITABLE]: true,\n\t\t\t[CONFIGURABLE]: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\t[ENUMERABLE]: desc[ENUMERABLE],\n\t\t\t[VALUE]: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\tconst args = arguments\n\t\targs[0] = args[0][0]\n\t\treturn fn.apply(this, args)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? VALUE in desc\n\t\t\t? desc[VALUE]\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: ImmerState) {\n\tif (!state.copy_) {\n\t\t// Actually create the `assigned_` map now that we\n\t\t// know this is a modified draft.\n\t\tstate.assigned_ = new Map()\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n","import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent,\n\tImmerScope,\n\tregisterChildFinalizationCallback,\n\tArchType,\n\tMapSetPlugin,\n\tAnyMap,\n\tAnySet,\n\tisObjectish,\n\tisFunction,\n\tisBoolean,\n\tPluginMapSet,\n\tPluginPatches\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\"\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\tuseStrictIteration_: boolean = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t\tuseStrictIteration?: boolean\n\t}) {\n\t\tif (isBoolean(config?.autoFreeze)) this.setAutoFreeze(config!.autoFreeze)\n\t\tif (isBoolean(config?.useStrictShallowCopy))\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t\tif (isBoolean(config?.useStrictIteration))\n\t\t\tthis.setUseStrictIteration(config!.useStrictIteration)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (isFunction(base) && !isFunction(recipe)) {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (!isFunction(recipe)) die(6)\n\t\tif (patchListener !== undefined && !isFunction(patchListener)) die(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(scope, base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || !isObjectish(base)) {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(PluginPatches).generateReplacementPatches_(base, result, {\n\t\t\t\t\tpatches_: p,\n\t\t\t\t\tinversePatches_: ip\n\t\t\t\t} as ImmerScope) // dummy scope\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (isFunction(base)) {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(scope, base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\t/**\n\t * Pass false to use faster iteration that skips non-enumerable properties\n\t * but still handles symbols for compatibility.\n\t *\n\t * By default, strict iteration is enabled (includes all own properties).\n\t */\n\tsetUseStrictIteration(value: boolean) {\n\t\tthis.useStrictIteration_ = value\n\t}\n\n\tshouldUseStrictIteration(): boolean {\n\t\treturn this.useStrictIteration_\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(PluginPatches).applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\trootScope: ImmerScope,\n\tvalue: T,\n\tparent?: ImmerState,\n\tkey?: string | number | symbol\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\t// returning a tuple here lets us skip a proxy access\n\t// to DRAFT_STATE later\n\tconst [draft, state] = isMap(value)\n\t\t? getPlugin(PluginMapSet).proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(PluginMapSet).proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent?.scope_ ?? getCurrentScope()\n\tscope.drafts_.push(draft)\n\n\t// Ensure the parent callbacks are passed down so we actually\n\t// track all callbacks added throughout the tree\n\tstate.callbacks_ = parent?.callbacks_ ?? []\n\tstate.key_ = key\n\n\tif (parent && key !== undefined) {\n\t\tregisterChildFinalizationCallback(parent, state, key)\n\t} else {\n\t\t// It's a root draft, register it with the scope\n\t\tstate.callbacks_.push(function rootDraftCleanup(rootScope) {\n\t\t\trootScope.mapSetPlugin_?.fixSetContents(state)\n\n\t\t\tconst {patchPlugin_} = rootScope\n\n\t\t\tif (state.modified_ && patchPlugin_) {\n\t\t\t\tpatchPlugin_.generatePatches_(state, [], rootScope)\n\t\t\t}\n\t\t})\n\t}\n\n\treturn draft as any\n}\n","import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tlet strict = true // Default to strict for compatibility\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t\tstrict = state.scope_.immer_.shouldUseStrictIteration()\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(\n\t\tcopy,\n\t\t(key, childValue) => {\n\t\t\tset(copy, key, currentImpl(childValue))\n\t\t},\n\t\tstrict\n\t)\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n","import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors,\n\tDRAFT_STATE,\n\tgetProxyDraft,\n\tImmerScope,\n\tisObjectish,\n\tisFunction,\n\tCONSTRUCTOR,\n\tPluginPatches,\n\tisArray,\n\tPROTOTYPE\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tfunction getPath(state: ImmerState, path: PatchPath = []): PatchPath | null {\n\t\t// Step 1: Check if state has a stored key\n\t\tif (\"key_\" in state && state.key_ !== undefined) {\n\t\t\t// Step 2: Validate the key is still valid in parent\n\n\t\t\tconst parentCopy = state.parent_!.copy_ ?? state.parent_!.base_\n\t\t\tconst proxyDraft = getProxyDraft(get(parentCopy, state.key_!))\n\t\t\tconst valueAtKey = get(parentCopy, state.key_!)\n\n\t\t\tif (valueAtKey === undefined) {\n\t\t\t\treturn null\n\t\t\t}\n\n\t\t\t// Check if the value at the key is still related to this draft\n\t\t\t// It should be either the draft itself, the base, or the copy\n\t\t\tif (\n\t\t\t\tvalueAtKey !== state.draft_ &&\n\t\t\t\tvalueAtKey !== state.base_ &&\n\t\t\t\tvalueAtKey !== state.copy_\n\t\t\t) {\n\t\t\t\treturn null // Value was replaced with something else\n\t\t\t}\n\t\t\tif (proxyDraft != null && proxyDraft.base_ !== state.base_) {\n\t\t\t\treturn null // Different draft\n\t\t\t}\n\n\t\t\t// Step 3: Handle Set case specially\n\t\t\tconst isSet = state.parent_!.type_ === ArchType.Set\n\t\t\tlet key: string | number\n\n\t\t\tif (isSet) {\n\t\t\t\t// For Sets, find the index in the drafts_ map\n\t\t\t\tconst setParent = state.parent_ as SetState\n\t\t\t\tkey = Array.from(setParent.drafts_.keys()).indexOf(state.key_)\n\t\t\t} else {\n\t\t\t\tkey = state.key_ as string | number\n\t\t\t}\n\n\t\t\t// Step 4: Validate key still exists in parent\n\t\t\tif (!((isSet && parentCopy.size > key) || has(parentCopy, key))) {\n\t\t\t\treturn null // Key deleted\n\t\t\t}\n\n\t\t\t// Step 5: Add key to path\n\t\t\tpath.push(key)\n\t\t}\n\n\t\t// Step 6: Recurse to parent if exists\n\t\tif (state.parent_) {\n\t\t\treturn getPath(state.parent_, path)\n\t\t}\n\n\t\t// Step 7: At root - reverse path and validate\n\t\tpath.reverse()\n\n\t\ttry {\n\t\t\t// Validate path can be resolved from ROOT\n\t\t\tresolvePath(state.copy_, path)\n\t\t} catch (e) {\n\t\t\treturn null // Path invalid\n\t\t}\n\n\t\treturn path\n\t}\n\n\t// NEW: Add resolvePath helper function\n\tfunction resolvePath(base: any, path: PatchPath): any {\n\t\tlet current = base\n\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\tconst key = path[i]\n\t\t\tcurrent = get(current, key)\n\t\t\tif (!isObjectish(current) || current === null) {\n\t\t\t\tthrow new Error(`Cannot resolve path at '${path.join(\"/\")}'`)\n\t\t\t}\n\t\t}\n\t\treturn current\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tscope: ImmerScope\n\t): void {\n\t\tif (state.scope_.processedForPatches_.has(state)) {\n\t\t\treturn\n\t\t}\n\n\t\tstate.scope_.processedForPatches_.add(state)\n\n\t\tconst {patches_, inversePatches_} = scope\n\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches_!,\n\t\t\t\t\tinversePatches_!\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tconst copiedItem = copy_[i]\n\t\t\tconst baseItem = base_[i]\n\t\t\tif (assigned_?.get(i.toString()) && copiedItem !== baseItem) {\n\t\t\t\tconst childState = copiedItem?.[DRAFT_STATE]\n\t\t\t\tif (childState && childState.modified_) {\n\t\t\t\t\t// Skip - let the child generate its own patches\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copiedItem)\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(baseItem)\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_, type_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key, type_)\n\t\t\tconst value = get(copy_!, key, type_)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(\n\t\t\t\top === REMOVE\n\t\t\t\t\t? {op, path}\n\t\t\t\t\t: {op, path, value: clonePatchValueIfNeeded(value)}\n\t\t\t)\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tscope: ImmerScope\n\t): void {\n\t\tconst {patches_, inversePatches_} = scope\n\t\tpatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches_!.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === CONSTRUCTOR)\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (isFunction(base) && p === PROTOTYPE) die(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (!isObjectish(base)) die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(PluginPatches, {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_,\n\t\tgetPath\n\t})\n}\n","// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach,\n\tgetValue,\n\tPluginMapSet\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(state.scope_, value, state, key)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, MapState] {\n\t\t// @ts-ignore\n\t\tconst map = new DraftMap(target, parent)\n\t\treturn [map as any, map[DRAFT_STATE]]\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tcallbacks_: []\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(\n\t\ttarget: T,\n\t\tparent?: ImmerState\n\t): [T, SetState] {\n\t\t// @ts-ignore\n\t\tconst set = new DraftSet(target, parent)\n\t\treturn [set as any, set[DRAFT_STATE]]\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(state.scope_, value, state, value)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tfunction fixSetContents(target: ImmerState) {\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\tif (target.type_ === ArchType.Set && target.copy_) {\n\t\t\tconst copy = new Set(target.copy_)\n\t\t\ttarget.copy_.clear()\n\t\t\tcopy.forEach(value => {\n\t\t\t\ttarget.copy_!.add(getValue(value))\n\t\t\t})\n\t\t}\n\t}\n\n\tloadPlugin(PluginMapSet, {proxyMap_, proxySet_, fixSetContents})\n}\n"],"mappings":"ubAAA,IAAAA,GAAA,GAAAC,GAAAD,GAAA,WAAAE,GAAA,iBAAAC,GAAA,cAAAC,GAAA,kBAAAC,GAAA,gBAAAC,GAAA,YAAAC,GAAA,iBAAAC,GAAA,kBAAAC,GAAA,gBAAAC,GAAA,WAAAC,EAAA,cAAAC,EAAA,YAAAC,EAAA,gBAAAC,EAAA,YAAAC,EAAA,aAAAC,GAAA,YAAAC,GAAA,uBAAAC,GAAA,kBAAAC,GAAA,0BAAAC,GAAA,4BAAAC,KAAA,eAAAC,GAAAtB,ICKO,IAAMuB,EAAyB,OAAO,IAAI,eAAe,EAUnDC,EAA2B,OAAO,IAAI,iBAAiB,EAEvDC,EAA6B,OAAO,IAAI,aAAa,ECuB3D,SAASC,EAAIC,KAAkBC,EAAoB,CAMzD,MAAM,IAAI,MACT,8BAA8BD,0CAC/B,CACD,CCnCA,IAAME,EAAI,OAEGC,EAAiBD,EAAE,eAEnBE,EAAc,cACdC,EAAY,YAEZC,GAAe,eACfC,GAAa,aACbC,GAAW,WACXC,GAAQ,QAIVC,EAAWC,GAAwB,CAAC,CAACA,GAAS,CAAC,CAACA,EAAMC,CAAW,EAIrE,SAASC,EAAYF,EAAqB,CAChD,OAAKA,EAEJG,GAAcH,CAAK,GACnBI,EAAQJ,CAAK,GACb,CAAC,CAACA,EAAMK,CAAS,GACjB,CAAC,CAACL,EAAMP,CAAW,IAAIY,CAAS,GAChCC,EAAMN,CAAK,GACXO,EAAMP,CAAK,EAPO,EASpB,CAEA,IAAMQ,GAAmBjB,EAAEG,CAAS,EAAED,CAAW,EAAE,SAAS,EACtDgB,GAAoB,IAAI,QAEvB,SAASN,GAAcH,EAAqB,CAClD,GAAI,CAACA,GAAS,CAACU,EAAYV,CAAK,EAAG,MAAO,GAC1C,IAAMW,EAAQnB,EAAeQ,CAAK,EAClC,GAAIW,IAAU,MAAQA,IAAUpB,EAAEG,CAAS,EAAG,MAAO,GAErD,IAAMkB,EAAOrB,EAAE,eAAe,KAAKoB,EAAOlB,CAAW,GAAKkB,EAAMlB,CAAW,EAC3E,GAAImB,IAAS,OAAQ,MAAO,GAE5B,GAAI,CAACC,EAAWD,CAAI,EAAG,MAAO,GAE9B,IAAIE,EAAaL,GAAkB,IAAIG,CAAI,EAC3C,OAAIE,IAAe,SAClBA,EAAa,SAAS,SAAS,KAAKF,CAAI,EACxCH,GAAkB,IAAIG,EAAME,CAAU,GAGhCA,IAAeN,EACvB,CAKO,SAASO,GAASf,EAA0B,CAClD,OAAKD,EAAQC,CAAK,GAAGgB,EAAI,GAAIhB,CAAK,EAC3BA,EAAMC,CAAW,EAAEgB,CAC3B,CAgBO,SAASC,EAAKC,EAAUC,EAAWC,EAAkB,GAAM,CAC7DC,EAAYH,CAAG,IAAM,GAGXE,EAAS,QAAQ,QAAQF,CAAG,EAAI5B,EAAE,KAAK4B,CAAG,GAClD,QAAQI,GAAO,CACnBH,EAAKG,EAAKJ,EAAII,CAAG,EAAGJ,CAAG,CACxB,CAAC,EAEDA,EAAI,QAAQ,CAACK,EAAYC,IAAeL,EAAKK,EAAOD,EAAOL,CAAG,CAAC,CAEjE,CAGO,SAASG,EAAYI,EAAsB,CACjD,IAAMC,EAAgCD,EAAMzB,CAAW,EACvD,OAAO0B,EACJA,EAAMC,EACNxB,EAAQsB,CAAK,IAEbpB,EAAMoB,CAAK,IAEXnB,EAAMmB,CAAK,KAGf,CAGO,IAAIG,EAAM,CAChBH,EACAI,EACAC,EAAOT,EAAYI,CAAK,IAExBK,IAAS,EACNL,EAAM,IAAII,CAAI,EACdvC,EAAEG,CAAS,EAAE,eAAe,KAAKgC,EAAOI,CAAI,EAGrCE,EAAM,CAChBN,EACAI,EACAC,EAAOT,EAAYI,CAAK,IAGxBK,IAAS,EAAeL,EAAM,IAAII,CAAI,EAAIJ,EAAMI,CAAI,EAG1CG,GAAM,CAChBP,EACAQ,EACAlC,EACA+B,EAAOT,EAAYI,CAAK,IACpB,CACAK,IAAS,EAAcL,EAAM,IAAIQ,EAAgBlC,CAAK,EACjD+B,IAAS,EACjBL,EAAM,IAAI1B,CAAK,EACT0B,EAAMQ,CAAc,EAAIlC,CAChC,EAGO,SAASmC,GAAGC,EAAQC,EAAiB,CAE3C,OAAID,IAAMC,EACFD,IAAM,GAAK,EAAIA,IAAM,EAAIC,EAEzBD,IAAMA,GAAKC,IAAMA,CAE1B,CAEO,IAAIjC,EAAU,MAAM,QAGhBE,EAASgC,GAAkCA,aAAkB,IAG7D/B,EAAS+B,GAAkCA,aAAkB,IAE7D5B,EAAe4B,GAAgB,OAAOA,GAAW,SAEjDzB,EAAcyB,GACxB,OAAOA,GAAW,WAERC,GAAaD,GACvB,OAAOA,GAAW,UAERE,GAAgCxC,GACrCU,EAAYV,CAAK,EACdA,IAAiCC,CAAW,EADpB,KAKtBwC,EAAUd,GAA2BA,EAAMe,GAASf,EAAMV,EAE1D0B,GAA8B3C,GAAgB,CACxD,IAAM4C,EAAaJ,GAAcxC,CAAK,EACtC,OAAO4C,EAAaA,EAAWF,GAASE,EAAW3B,EAAQjB,CAC5D,EAEW6C,GAAiBlB,GAC3BA,EAAMmB,EAAYnB,EAAMe,EAAQf,EAAMV,EAGhC,SAAS8B,GAAYC,EAAW3B,EAAoB,CAC1D,GAAIf,EAAM0C,CAAI,EACb,OAAO,IAAI,IAAIA,CAAI,EAEpB,GAAIzC,EAAMyC,CAAI,EACb,OAAO,IAAI,IAAIA,CAAI,EAEpB,GAAI5C,EAAQ4C,CAAI,EAAG,OAAO,MAAMtD,CAAS,EAAE,MAAM,KAAKsD,CAAI,EAE1D,IAAMC,EAAU9C,GAAc6C,CAAI,EAElC,GAAI3B,IAAW,IAASA,IAAW,cAAgB,CAAC4B,EAAU,CAE7D,IAAMC,EAAc3D,EAAE,0BAA0ByD,CAAI,EACpD,OAAOE,EAAYjD,CAAkB,EACrC,IAAIkD,EAAO,QAAQ,QAAQD,CAAW,EACtC,QAAS,EAAI,EAAG,EAAIC,EAAK,OAAQ,IAAK,CACrC,IAAM5B,EAAW4B,EAAK,CAAC,EACjBC,EAAOF,EAAY3B,CAAG,EACxB6B,EAAKvD,EAAQ,IAAM,KACtBuD,EAAKvD,EAAQ,EAAI,GACjBuD,EAAKzD,EAAY,EAAI,KAKlByD,EAAK,KAAOA,EAAK,OACpBF,EAAY3B,CAAG,EAAI,CAClB,CAAC5B,EAAY,EAAG,GAChB,CAACE,EAAQ,EAAG,GACZ,CAACD,EAAU,EAAGwD,EAAKxD,EAAU,EAC7B,CAACE,EAAK,EAAGkD,EAAKzB,CAAG,CAClB,GAEF,OAAOhC,EAAE,OAAOC,EAAewD,CAAI,EAAGE,CAAW,MAC3C,CAEN,IAAMvC,EAAQnB,EAAewD,CAAI,EACjC,GAAIrC,IAAU,MAAQsC,EACrB,MAAO,CAAC,GAAGD,CAAI,EAEhB,IAAM7B,EAAM5B,EAAE,OAAOoB,CAAK,EAC1B,OAAOpB,EAAE,OAAO4B,EAAK6B,CAAI,EAE3B,CAUO,SAASK,EAAUlC,EAAUmC,EAAgB,GAAU,CAC7D,OAAIC,GAASpC,CAAG,GAAKpB,EAAQoB,CAAG,IAC5BG,EAAYH,CAAG,EAAI,GACtB5B,EAAE,iBAAiB4B,EAAK,CACvB,IAAKqC,GACL,IAAKA,GACL,MAAOA,GACP,OAAQA,EACT,CAAC,EAEFjE,EAAE,OAAO4B,CAAG,EACRmC,GAGHpC,EACCC,EACA,CAACsC,EAAMzD,IAAU,CAChBqD,EAAOrD,EAAO,EAAI,CACnB,EACA,EACD,GACMmB,CACR,CAEA,SAASuC,IAA8B,CACtC1C,EAAI,CAAC,CACN,CAEA,IAAMwC,GAA2B,CAChC,CAAC1D,EAAK,EAAG4D,EACV,EAEO,SAASH,GAASpC,EAAmB,CAE3C,OAAIA,IAAQ,MAAQ,CAACT,EAAYS,CAAG,EAAU,GACvC5B,EAAE,SAAS4B,CAAG,CACtB,CC5QO,IAAMwC,EAAe,SACfC,EAAgB,UAwBvBC,GAGF,CAAC,EAIE,SAASC,EACfC,EACiC,CACjC,IAAMC,EAASH,GAAQE,CAAS,EAChC,OAAKC,GACJC,EAAI,EAAGF,CAAS,EAGVC,CACR,CAEO,IAAIE,GAA2CH,GACrD,CAAC,CAACF,GAAQE,CAAS,EAEb,SAASI,GACfJ,EACAK,EACO,CACFP,GAAQE,CAAS,IAAGF,GAAQE,CAAS,EAAIK,EAC/C,CC9BA,IAAIC,GAEOC,EAAkB,IAAMD,GAE/BE,GAAc,CACjBC,EACAC,KACiB,CACjBC,EAAS,CAAC,EACVF,IACAC,IAGAE,EAAgB,GAChBC,EAAoB,EACpBC,EAAa,IAAI,IACjBC,EAAsB,IAAI,IAC1BC,EAAeC,GAAeC,CAAY,EACvCC,EAAUD,CAAY,EACtB,MACJ,GAEO,SAASE,GACfC,EACAC,EACC,CACGA,IACHD,EAAME,EAAeJ,EAAUK,CAAa,EAC5CH,EAAMI,EAAW,CAAC,EAClBJ,EAAMK,EAAkB,CAAC,EACzBL,EAAMM,EAAiBL,EAEzB,CAEO,SAASM,GAAYP,EAAmB,CAC9CQ,GAAWR,CAAK,EAChBA,EAAMV,EAAQ,QAAQmB,EAAW,EAEjCT,EAAMV,EAAU,IACjB,CAEO,SAASkB,GAAWR,EAAmB,CACzCA,IAAUf,KACbA,GAAee,EAAMZ,EAEvB,CAEO,IAAIsB,GAAcC,GACvB1B,GAAeE,GAAYF,GAAc0B,CAAK,EAEhD,SAASF,GAAYG,EAAgB,CACpC,IAAMC,EAAoBD,EAAME,CAAW,EACvCD,EAAME,IAAU,GAAmBF,EAAME,IAAU,EACtDF,EAAMG,EAAQ,EACVH,EAAMI,EAAW,EACvB,CC/DO,SAASC,GAAcC,EAAaC,EAAmB,CAC7DA,EAAMC,EAAqBD,EAAME,EAAQ,OACzC,IAAMC,EAAYH,EAAME,EAAS,CAAC,EAGlC,GAFmBH,IAAW,QAAaA,IAAWI,EAEtC,CACXA,EAAUC,CAAW,EAAEC,IAC1BC,GAAYN,CAAK,EACjBO,EAAI,CAAC,GAEFC,EAAYT,CAAM,IAErBA,EAASU,GAAST,EAAOD,CAAM,GAEhC,GAAM,CAACW,GAAY,EAAIV,EACnBU,GACHA,EAAaC,EACZR,EAAUC,CAAW,EAAEQ,EACvBb,EACAC,CACD,OAIDD,EAASU,GAAST,EAAOG,CAAS,EAGnC,OAAAU,GAAYb,EAAOD,EAAQ,EAAI,EAE/BO,GAAYN,CAAK,EACbA,EAAMc,GACTd,EAAMe,EAAgBf,EAAMc,EAAUd,EAAMgB,CAAgB,EAEtDjB,IAAWkB,EAAUlB,EAAS,MACtC,CAEA,SAASU,GAASS,EAAuBC,EAAY,CAEpD,GAAIC,GAASD,CAAK,EAAG,OAAOA,EAE5B,IAAME,EAAoBF,EAAMf,CAAW,EAC3C,GAAI,CAACiB,EAEJ,OADmBC,GAAYH,EAAOD,EAAUK,EAAaL,CAAS,EAKvE,GAAI,CAACM,GAAYH,EAAOH,CAAS,EAChC,OAAOC,EAIR,GAAI,CAACE,EAAMhB,EACV,OAAOgB,EAAMT,EAGd,GAAI,CAACS,EAAMI,EAAY,CAEtB,GAAM,CAACC,GAAU,EAAIL,EACrB,GAAIK,EACH,KAAOA,EAAW,OAAS,GACTA,EAAW,IAAI,EACvBR,CAAS,EAIpBS,GAA2BN,EAAOH,CAAS,EAI5C,OAAOG,EAAMO,CACd,CAEA,SAASf,GAAYb,EAAmBmB,EAAYU,EAAO,GAAO,CAE7D,CAAC7B,EAAM8B,GAAW9B,EAAM+B,EAAOC,GAAehC,EAAMiC,GACvDC,EAAOf,EAAOU,CAAI,CAEpB,CAEA,SAASM,GAAmBd,EAAmB,CAC9CA,EAAMI,EAAa,GACnBJ,EAAMe,EAAOnC,GACd,CAEA,IAAIuB,GAAc,CAACH,EAAmBH,IACrCG,EAAMe,IAAWlB,EAGZmB,GAAuD,CAAC,EAIvD,SAASC,GACfC,EACAC,EACAC,EACAC,EACO,CACP,IAAMC,EAAaC,EAAOL,CAAM,EAC1BM,EAAaN,EAAOO,EAG1B,GAAIJ,IAAgB,QACEK,EAAIJ,EAAYD,EAAaG,CAAU,IACvCL,EAAY,CAEhCQ,GAAIL,EAAYD,EAAaD,EAAgBI,CAAU,EACvD,OAQF,GAAI,CAACN,EAAOU,EAAiB,CAC5B,IAAMC,EAAkBX,EAAOU,EAAkB,IAAI,IAGrDE,EAAKR,EAAY,CAACS,EAAKjC,IAAU,CAChC,GAAIkC,EAAQlC,CAAK,EAAG,CACnB,IAAMmC,EAAOJ,EAAe,IAAI/B,CAAK,GAAK,CAAC,EAC3CmC,EAAK,KAAKF,CAAG,EACbF,EAAe,IAAI/B,EAAOmC,CAAI,EAEhC,CAAC,EAIF,IAAMC,EACLhB,EAAOU,EAAgB,IAAIT,CAAU,GAAKH,GAG3C,QAAWmB,KAAYD,EACtBP,GAAIL,EAAYa,EAAUf,EAAgBI,CAAU,CAEtD,CAKO,SAASY,GACflB,EACAmB,EACAN,EACC,CACDb,EAAOb,EAAW,KAAK,SAAsBR,EAAW,CACvD,IAAMG,EAAoBqC,EAG1B,GAAI,CAACrC,GAAS,CAACG,GAAYH,EAAOH,CAAS,EAC1C,OAIDA,EAAUyC,GAAe,eAAetC,CAAK,EAE7C,IAAMoB,EAAiBmB,GAAcvC,CAAK,EAG1CiB,GAAoBC,EAAQlB,EAAMwC,GAAUxC,EAAOoB,EAAgBW,CAAG,EAEtEzB,GAA2BN,EAAOH,CAAS,CAC5C,CAAC,CACF,CAEA,SAASS,GAA2BN,EAAmBH,EAAuB,CAM7E,GAJCG,EAAMhB,GACN,CAACgB,EAAMI,IACNJ,EAAMyB,IAAU,IAAiBzB,EAAMyC,GAAW,MAAQ,GAAK,GAE7C,CACnB,GAAM,CAACpD,GAAY,EAAIQ,EACvB,GAAIR,EAAc,CACjB,IAAMqD,EAAWrD,EAAc,QAAQW,CAAK,EAExC0C,GACHrD,EAAcsD,EAAiB3C,EAAO0C,EAAU7C,CAAS,EAI3DiB,GAAmBd,CAAK,EAE1B,CAEO,SAAS4C,GACfC,EACAd,EACAjC,EACC,CACD,GAAM,CAACiB,CAAM,EAAI8B,EAEjB,GAAIb,EAAQlC,CAAK,EAAG,CACnB,IAAME,EAAoBF,EAAMf,CAAW,EACvCoB,GAAYH,EAAOe,CAAM,GAG5Bf,EAAMK,EAAW,KAAK,UAAiC,CAEtDyC,GAAYD,CAAM,EAElB,IAAMzB,EAAiBmB,GAAcvC,CAAK,EAE1CiB,GAAoB4B,EAAQ/C,EAAOsB,EAAgBW,CAAG,CACvD,CAAC,OAEQ5C,EAAYW,CAAK,GAE3B+C,EAAOxC,EAAW,KAAK,UAA8B,CACpD,IAAM0C,EAAaxB,EAAOsB,CAAM,EAE5BnB,EAAIqB,EAAYhB,EAAKc,EAAOpB,CAAK,IAAM3B,GAKzCiB,EAAOlC,EAAQ,OAAS,IACtBgE,EAAyCJ,EAAW,IAAIV,CAAG,GAC5D,MAAW,IACZc,EAAOtC,GAIPN,GACCyB,EAAImB,EAAOtC,EAAOwB,EAAKc,EAAOpB,CAAK,EACnCV,EAAOb,EACPa,CACD,CAGH,CAAC,CAEH,CAEO,SAASd,GACf4C,EACAG,EACAnD,EACC,CAWD,MAVI,CAACA,EAAUa,EAAOC,GAAed,EAAUjB,EAAqB,GAWnEoD,EAAQa,CAAM,GACdG,EAAW,IAAIH,CAAM,GACrB,CAAC1D,EAAY0D,CAAM,GACnB9C,GAAS8C,CAAM,IAKhBG,EAAW,IAAIH,CAAM,EAGrBf,EAAKe,EAAQ,CAACd,EAAKjC,IAAU,CAC5B,GAAIkC,EAAQlC,CAAK,EAAG,CACnB,IAAME,EAAoBF,EAAMf,CAAW,EAC3C,GAAIoB,GAAYH,EAAOH,CAAS,EAAG,CAGlC,IAAMoD,EAAeV,GAAcvC,CAAK,EAExC2B,GAAIkB,EAAQd,EAAKkB,EAAcJ,EAAOpB,CAAK,EAE3CX,GAAmBd,CAAK,QAEfb,EAAYW,CAAK,GAE3BG,GAAYH,EAAOkD,EAAYnD,CAAS,CAE1C,CAAC,GAEMgD,CACR,CC7PO,SAASK,GACfC,EACAC,EACuC,CACvC,IAAMC,EAAcC,EAAQH,CAAI,EAC1BI,EAAoB,CACzBC,EAAOH,MAEPI,EAAQL,EAASA,EAAOK,EAASC,EAAgB,EAEjDC,EAAW,GAEXC,EAAY,GAGZC,EAAW,OAEXC,EAASV,EAETW,EAAOZ,EAEPa,EAAQ,KAERC,EAAO,KAEPC,EAAS,KACTC,EAAW,GAEXC,EAAY,MACb,EAQIC,EAAYd,EACZe,EAA2CC,GAC3ClB,IACHgB,EAAS,CAACd,CAAK,EACfe,EAAQE,IAGT,GAAM,CAAC,OAAAC,EAAQ,MAAAC,CAAK,EAAI,MAAM,UAAUL,EAAQC,CAAK,EACrD,OAAAf,EAAMS,EAASU,EACfnB,EAAMW,EAAUO,EACT,CAACC,EAAcnB,CAAK,CAC5B,CAKO,IAAMgB,GAAwC,CACpD,IAAIhB,EAAOoB,EAAM,CAChB,GAAIA,IAASC,EAAa,OAAOrB,EAEjC,IAAMsB,EAASC,EAAOvB,CAAK,EAC3B,GAAI,CAACwB,EAAIF,EAAQF,EAAMpB,EAAMC,CAAK,EAEjC,OAAOwB,GAAkBzB,EAAOsB,EAAQF,CAAI,EAE7C,IAAMM,EAAQJ,EAAOF,CAAI,EACzB,GAAIpB,EAAMK,GAAc,CAACsB,EAAYD,CAAK,EACzC,OAAOA,EAIR,GAAIA,IAAUE,GAAK5B,EAAMQ,EAAOY,CAAI,EAAG,CACtCS,GAAY7B,CAAK,EAEjB,IAAM8B,EAAW9B,EAAMC,IAAU,EAAiB,CAAEmB,EAAkBA,EAChEW,EAAaC,EAAYhC,EAAME,EAAQwB,EAAO1B,EAAO8B,CAAQ,EAEnE,OAAQ9B,EAAMU,EAAOoB,CAAQ,EAAIC,EAElC,OAAOL,CACR,EACA,IAAI1B,EAAOoB,EAAM,CAChB,OAAOA,KAAQG,EAAOvB,CAAK,CAC5B,EACA,QAAQA,EAAO,CACd,OAAO,QAAQ,QAAQuB,EAAOvB,CAAK,CAAC,CACrC,EACA,IACCA,EACAoB,EACAM,EACC,CACD,IAAMO,EAAOC,GAAuBX,EAAOvB,CAAK,EAAGoB,CAAI,EACvD,GAAIa,GAAM,IAGT,OAAAA,EAAK,IAAI,KAAKjC,EAAMS,EAAQiB,CAAK,EAC1B,GAER,GAAI,CAAC1B,EAAMI,EAAW,CAGrB,IAAM+B,EAAUP,GAAKL,EAAOvB,CAAK,EAAGoB,CAAI,EAElCgB,EAAiCD,IAAUd,CAAW,EAC5D,GAAIe,GAAgBA,EAAa5B,IAAUkB,EAC1C,OAAA1B,EAAMU,EAAOU,CAAI,EAAIM,EACrB1B,EAAMM,EAAW,IAAIc,EAAM,EAAK,EACzB,GAER,GACCiB,GAAGX,EAAOS,CAAO,IAChBT,IAAU,QAAaF,EAAIxB,EAAMQ,EAAOY,EAAMpB,EAAMC,CAAK,GAE1D,MAAO,GACR4B,GAAY7B,CAAK,EACjBsC,EAAYtC,CAAK,EAGlB,OACEA,EAAMU,EAAOU,CAAI,IAAMM,IAEtBA,IAAU,QAAaN,KAAQpB,EAAMU,IAEtC,OAAO,MAAMgB,CAAK,GAAK,OAAO,MAAM1B,EAAMU,EAAOU,CAAI,CAAC,IAKxDpB,EAAMU,EAAOU,CAAI,EAAIM,EACrB1B,EAAMM,EAAW,IAAIc,EAAM,EAAI,EAE/BmB,GAAqBvC,EAAOoB,EAAMM,CAAK,GAChC,EACR,EACA,eAAe1B,EAAOoB,EAAc,CACnC,OAAAS,GAAY7B,CAAK,EAEb4B,GAAK5B,EAAMQ,EAAOY,CAAI,IAAM,QAAaA,KAAQpB,EAAMQ,GAC1DR,EAAMM,EAAW,IAAIc,EAAM,EAAK,EAChCkB,EAAYtC,CAAK,GAGjBA,EAAMM,EAAW,OAAOc,CAAI,EAEzBpB,EAAMU,GACT,OAAOV,EAAMU,EAAMU,CAAI,EAEjB,EACR,EAGA,yBAAyBpB,EAAOoB,EAAM,CACrC,IAAMoB,EAAQjB,EAAOvB,CAAK,EACpBiC,EAAO,QAAQ,yBAAyBO,EAAOpB,CAAI,EACzD,OAAKa,GACE,CACN,CAACQ,EAAQ,EAAG,GACZ,CAACC,EAAY,EAAG1C,EAAMC,IAAU,GAAkBmB,IAAS,SAC3D,CAACuB,EAAU,EAAGV,EAAKU,EAAU,EAC7B,CAACC,EAAK,EAAGJ,EAAMpB,CAAI,CACpB,CACD,EACA,gBAAiB,CAChByB,EAAI,EAAE,CACP,EACA,eAAe7C,EAAO,CACrB,OAAO8C,EAAe9C,EAAMQ,CAAK,CAClC,EACA,gBAAiB,CAChBqC,EAAI,EAAE,CACP,CACD,EAMM5B,GAA8C,CAAC,EACrD8B,EAAK/B,GAAa,CAACgC,EAAKC,IAAO,CAE9BhC,GAAW+B,CAAG,EAAI,UAAW,CAC5B,IAAME,EAAO,UACb,OAAAA,EAAK,CAAC,EAAIA,EAAK,CAAC,EAAE,CAAC,EACZD,EAAG,MAAM,KAAMC,CAAI,CAC3B,CACD,CAAC,EACDjC,GAAW,eAAiB,SAASjB,EAAOoB,EAAM,CAIjD,OAAOH,GAAW,IAAK,KAAK,KAAMjB,EAAOoB,EAAM,MAAS,CACzD,EACAH,GAAW,IAAM,SAASjB,EAAOoB,EAAMM,EAAO,CAO7C,OAAOV,GAAY,IAAK,KAAK,KAAMhB,EAAM,CAAC,EAAGoB,EAAMM,EAAO1B,EAAM,CAAC,CAAC,CACnE,EAGA,SAAS4B,GAAKuB,EAAgB/B,EAAmB,CAChD,IAAMpB,EAAQmD,EAAM9B,CAAW,EAE/B,OADerB,EAAQuB,EAAOvB,CAAK,EAAImD,GACzB/B,CAAI,CACnB,CAEA,SAASK,GAAkBzB,EAAmBsB,EAAaF,EAAmB,CAC7E,IAAMa,EAAOC,GAAuBZ,EAAQF,CAAI,EAChD,OAAOa,EACJW,MAASX,EACRA,EAAKW,EAAK,EAGVX,EAAK,KAAK,KAAKjC,EAAMS,CAAM,EAC5B,MACJ,CAEA,SAASyB,GACRZ,EACAF,EACiC,CAEjC,GAAI,EAAEA,KAAQE,GAAS,OACvB,IAAI8B,EAAQN,EAAexB,CAAM,EACjC,KAAO8B,GAAO,CACb,IAAMnB,EAAO,OAAO,yBAAyBmB,EAAOhC,CAAI,EACxD,GAAIa,EAAM,OAAOA,EACjBmB,EAAQN,EAAeM,CAAK,EAG9B,CAEO,SAASd,EAAYtC,EAAmB,CACzCA,EAAMI,IACVJ,EAAMI,EAAY,GACdJ,EAAMO,GACT+B,EAAYtC,EAAMO,CAAO,EAG5B,CAEO,SAASsB,GAAY7B,EAAmB,CACzCA,EAAMU,IAGVV,EAAMM,EAAY,IAAI,IACtBN,EAAMU,EAAQ2C,GACbrD,EAAMQ,EACNR,EAAME,EAAOoD,EAAOC,CACrB,EAEF,CCpQO,IAAMC,GAAN,KAAoC,CAK1C,YAAYC,EAIT,CARH,KAAAC,EAAuB,GACvB,KAAAC,EAAoC,GACpC,KAAAC,EAA+B,GAiC/B,aAAoB,CAACC,EAAWC,EAAcC,IAAwB,CAErE,GAAIC,EAAWH,CAAI,GAAK,CAACG,EAAWF,CAAM,EAAG,CAC5C,IAAMG,EAAcH,EACpBA,EAASD,EAET,IAAMK,EAAO,KACb,OAAO,SAENL,EAAOI,KACJE,EACF,CACD,OAAOD,EAAK,QAAQL,EAAOO,GAAmBN,EAAO,KAAK,KAAMM,EAAO,GAAGD,CAAI,CAAC,CAChF,EAGIH,EAAWF,CAAM,GAAGO,EAAI,CAAC,EAC1BN,IAAkB,QAAa,CAACC,EAAWD,CAAa,GAAGM,EAAI,CAAC,EAEpE,IAAIC,EAGJ,GAAIC,EAAYV,CAAI,EAAG,CACtB,IAAMW,EAAQC,GAAW,IAAI,EACvBC,EAAQC,EAAYH,EAAOX,EAAM,MAAS,EAC5Ce,EAAW,GACf,GAAI,CACHN,EAASR,EAAOY,CAAK,EACrBE,EAAW,EACZ,QAAE,CAEGA,EAAUC,GAAYL,CAAK,EAC1BM,GAAWN,CAAK,CACtB,CACA,OAAAO,GAAkBP,EAAOT,CAAa,EAC/BiB,GAAcV,EAAQE,CAAK,UACxB,CAACX,GAAQ,CAACoB,EAAYpB,CAAI,EAAG,CAKvC,GAJAS,EAASR,EAAOD,CAAI,EAChBS,IAAW,SAAWA,EAAST,GAC/BS,IAAWY,IAASZ,EAAS,QAC7B,KAAKZ,GAAayB,EAAOb,EAAQ,EAAI,EACrCP,EAAe,CAClB,IAAMqB,EAAa,CAAC,EACdC,EAAc,CAAC,EACrBC,EAAUC,CAAa,EAAEC,EAA4B3B,EAAMS,EAAQ,CAClEmB,EAAUL,EACVM,EAAiBL,CAClB,CAAe,EACftB,EAAcqB,EAAGC,CAAE,EAEpB,OAAOf,OACDD,EAAI,EAAGR,CAAI,CACnB,EAEA,wBAA0C,CAACA,EAAWC,IAAsB,CAE3E,GAAIE,EAAWH,CAAI,EAClB,MAAO,CAAC8B,KAAexB,IACtB,KAAK,mBAAmBwB,EAAQvB,GAAeP,EAAKO,EAAO,GAAGD,CAAI,CAAC,EAGrE,IAAIyB,EAAkBC,EAKtB,MAAO,CAJQ,KAAK,QAAQhC,EAAMC,EAAQ,CAACsB,EAAYC,IAAgB,CACtEO,EAAUR,EACVS,EAAiBR,CAClB,CAAC,EACeO,EAAUC,CAAe,CAC1C,EA7FKC,GAAUrC,GAAQ,UAAU,GAAG,KAAK,cAAcA,EAAQ,UAAU,EACpEqC,GAAUrC,GAAQ,oBAAoB,GACzC,KAAK,wBAAwBA,EAAQ,oBAAoB,EACtDqC,GAAUrC,GAAQ,kBAAkB,GACvC,KAAK,sBAAsBA,EAAQ,kBAAkB,CACvD,CA0FA,YAAiCI,EAAmB,CAC9CU,EAAYV,CAAI,GAAGQ,EAAI,CAAC,EACzB0B,EAAQlC,CAAI,IAAGA,EAAOmC,GAAQnC,CAAI,GACtC,IAAMW,EAAQC,GAAW,IAAI,EACvBC,EAAQC,EAAYH,EAAOX,EAAM,MAAS,EAChD,OAAAa,EAAMuB,CAAW,EAAEC,EAAY,GAC/BpB,GAAWN,CAAK,EACTE,CACR,CAEA,YACCN,EACAL,EACuC,CACvC,IAAM4B,EAAoBvB,GAAUA,EAAc6B,CAAW,GACzD,CAACN,GAAS,CAACA,EAAMO,IAAW7B,EAAI,CAAC,EACrC,GAAM,CAAC8B,EAAQ3B,CAAK,EAAImB,EACxB,OAAAZ,GAAkBP,EAAOT,CAAa,EAC/BiB,GAAc,OAAWR,CAAK,CACtC,CAOA,cAAc4B,EAAgB,CAC7B,KAAK1C,EAAc0C,CACpB,CAOA,wBAAwBA,EAAmB,CAC1C,KAAKzC,EAAwByC,CAC9B,CAQA,sBAAsBA,EAAgB,CACrC,KAAKxC,EAAsBwC,CAC5B,CAEA,0BAAoC,CACnC,OAAO,KAAKxC,CACb,CAEA,aAAkCC,EAAS+B,EAA8B,CAGxE,IAAIS,EACJ,IAAKA,EAAIT,EAAQ,OAAS,EAAGS,GAAK,EAAGA,IAAK,CACzC,IAAMC,EAAQV,EAAQS,CAAC,EACvB,GAAIC,EAAM,KAAK,SAAW,GAAKA,EAAM,KAAO,UAAW,CACtDzC,EAAOyC,EAAM,MACb,OAKED,EAAI,KACPT,EAAUA,EAAQ,MAAMS,EAAI,CAAC,GAG9B,IAAME,EAAmBjB,EAAUC,CAAa,EAAEiB,EAClD,OAAIT,EAAQlC,CAAI,EAER0C,EAAiB1C,EAAM+B,CAAO,EAG/B,KAAK,QAAQ/B,EAAOO,GAC1BmC,EAAiBnC,EAAOwB,CAAO,CAChC,CACD,CACD,EAEO,SAASjB,EACf8B,EACAL,EACAM,EACAC,EACyB,CAIzB,GAAM,CAACvC,EAAOuB,CAAK,EAAIiB,EAAMR,CAAK,EAC/Bd,EAAUuB,CAAY,EAAEC,EAAUV,EAAOM,CAAM,EAC/CK,EAAMX,CAAK,EACXd,EAAUuB,CAAY,EAAEG,EAAUZ,EAAOM,CAAM,EAC/CO,GAAiBb,EAAOM,CAAM,EAGjC,OADcA,GAAQP,GAAUe,EAAgB,GAC1CC,EAAQ,KAAK/C,CAAK,EAIxBuB,EAAMyB,EAAaV,GAAQU,GAAc,CAAC,EAC1CzB,EAAM0B,EAAOV,EAETD,GAAUC,IAAQ,OACrBW,GAAkCZ,EAAQf,EAAOgB,CAAG,EAGpDhB,EAAMyB,EAAW,KAAK,SAA0BX,EAAW,CAC1DA,EAAUc,GAAe,eAAe5B,CAAK,EAE7C,GAAM,CAAC6B,GAAY,EAAIf,EAEnBd,EAAM8B,GAAaD,GACtBA,EAAaE,EAAiB/B,EAAO,CAAC,EAAGc,CAAS,CAEpD,CAAC,EAGKrC,CACR,CClQO,SAASuD,GAAQC,EAAiB,CACxC,OAAKC,EAAQD,CAAK,GAAGE,EAAI,GAAIF,CAAK,EAC3BG,GAAYH,CAAK,CACzB,CAEA,SAASG,GAAYH,EAAiB,CACrC,GAAI,CAACI,EAAYJ,CAAK,GAAKK,GAASL,CAAK,EAAG,OAAOA,EACnD,IAAMM,EAAgCN,EAAMO,CAAW,EACnDC,EACAC,EAAS,GACb,GAAIH,EAAO,CACV,GAAI,CAACA,EAAMI,EAAW,OAAOJ,EAAMK,EAEnCL,EAAMM,EAAa,GACnBJ,EAAOK,GAAYb,EAAOM,EAAMQ,EAAOC,EAAOC,CAAqB,EACnEP,EAASH,EAAMQ,EAAOC,EAAO,yBAAyB,OAEtDP,EAAOK,GAAYb,EAAO,EAAI,EAG/B,OAAAiB,EACCT,EACA,CAACU,EAAKC,IAAe,CACpBC,GAAIZ,EAAMU,EAAKf,GAAYgB,CAAU,CAAC,CACvC,EACAV,CACD,EACIH,IACHA,EAAMM,EAAa,IAEbJ,CACR,CCXO,SAASa,IAAgB,CAe/B,SAASC,EAAQC,EAAmBC,EAAkB,CAAC,EAAqB,CAE3E,GAAI,SAAUD,GAASA,EAAME,IAAS,OAAW,CAGhD,IAAMC,EAAaH,EAAMI,EAASC,GAASL,EAAMI,EAASE,EACpDC,EAAaC,GAAcC,EAAIN,EAAYH,EAAME,CAAK,CAAC,EACvDQ,EAAaD,EAAIN,EAAYH,EAAME,CAAK,EAe9C,GAbIQ,IAAe,QAOlBA,IAAeV,EAAMW,GACrBD,IAAeV,EAAMM,GACrBI,IAAeV,EAAMK,GAIlBE,GAAc,MAAQA,EAAWD,IAAUN,EAAMM,EACpD,OAAO,KAIR,IAAMM,EAAQZ,EAAMI,EAASS,IAAU,EACnCC,EAEJ,GAAIF,EAAO,CAEV,IAAMG,EAAYf,EAAMI,EACxBU,EAAM,MAAM,KAAKC,EAAUC,EAAQ,KAAK,CAAC,EAAE,QAAQhB,EAAME,CAAI,OAE7DY,EAAMd,EAAME,EAIb,GAAI,EAAGU,GAAST,EAAW,KAAOW,GAAQG,EAAId,EAAYW,CAAG,GAC5D,OAAO,KAIRb,EAAK,KAAKa,CAAG,EAId,GAAId,EAAMI,EACT,OAAOL,EAAQC,EAAMI,EAASH,CAAI,EAInCA,EAAK,QAAQ,EAEb,GAAI,CAEHiB,EAAYlB,EAAMK,EAAOJ,CAAI,CAC9B,MAAE,CACD,OAAO,IACR,CAEA,OAAOA,CACR,CAGA,SAASiB,EAAYC,EAAWlB,EAAsB,CACrD,IAAImB,EAAUD,EACd,QAASE,EAAI,EAAGA,EAAIpB,EAAK,OAAS,EAAGoB,IAAK,CACzC,IAAMP,EAAMb,EAAKoB,CAAC,EAElB,GADAD,EAAUX,EAAIW,EAASN,CAAG,EACtB,CAACQ,EAAYF,CAAO,GAAKA,IAAY,KACxC,MAAM,IAAI,MAAM,2BAA2BnB,EAAK,KAAK,GAAG,IAAI,EAG9D,OAAOmB,CACR,CAEA,IAAMG,EAAU,UACVC,EAAM,MACNC,EAAS,SAEf,SAASC,EACR1B,EACA2B,EACAC,EACO,CACP,GAAI5B,EAAM6B,EAAOC,EAAqB,IAAI9B,CAAK,EAC9C,OAGDA,EAAM6B,EAAOC,EAAqB,IAAI9B,CAAK,EAE3C,GAAM,CAAC+B,IAAUC,GAAe,EAAIJ,EAEpC,OAAQ5B,EAAMa,EAAO,CACpB,OACA,OACC,OAAOoB,EACNjC,EACA2B,EACAI,EACAC,CACD,EACD,OACC,OAAOE,EACNlC,EACA2B,EACAI,EACAC,CACD,EACD,OACC,OAAOG,EACLnC,EACD2B,EACAI,EACAC,CACD,CACF,CACD,CAEA,SAASE,EACRlC,EACA2B,EACAS,EACAC,EACC,CACD,GAAI,CAAC/B,IAAOgC,GAAS,EAAItC,EACrBK,EAAQL,EAAMK,EAGdA,EAAM,OAASC,EAAM,SAEvB,CAACA,EAAOD,CAAK,EAAI,CAACA,EAAOC,CAAK,EAC9B,CAAC8B,EAASC,CAAc,EAAI,CAACA,EAAgBD,CAAO,GAItD,QAASf,EAAI,EAAGA,EAAIf,EAAM,OAAQe,IAAK,CACtC,IAAMkB,EAAalC,EAAMgB,CAAC,EACpBmB,EAAWlC,EAAMe,CAAC,EACxB,GAAIiB,GAAW,IAAIjB,EAAE,SAAS,CAAC,GAAKkB,IAAeC,EAAU,CAC5D,IAAMC,EAAaF,IAAaG,CAAW,EAC3C,GAAID,GAAcA,EAAWE,EAE5B,SAED,IAAM1C,EAAO0B,EAAS,OAAO,CAACN,CAAC,CAAC,EAChCe,EAAQ,KAAK,CACZ,GAAIb,EACJ,KAAAtB,EAGA,MAAO2C,EAAwBL,CAAU,CAC1C,CAAC,EACDF,EAAe,KAAK,CACnB,GAAId,EACJ,KAAAtB,EACA,MAAO2C,EAAwBJ,CAAQ,CACxC,CAAC,GAKH,QAASnB,EAAIf,EAAM,OAAQe,EAAIhB,EAAM,OAAQgB,IAAK,CACjD,IAAMpB,EAAO0B,EAAS,OAAO,CAACN,CAAC,CAAC,EAChCe,EAAQ,KAAK,CACZ,GAAIZ,EACJ,KAAAvB,EAGA,MAAO2C,EAAwBvC,EAAMgB,CAAC,CAAC,CACxC,CAAC,EAEF,QAASA,EAAIhB,EAAM,OAAS,EAAGC,EAAM,QAAUe,EAAG,EAAEA,EAAG,CACtD,IAAMpB,EAAO0B,EAAS,OAAO,CAACN,CAAC,CAAC,EAChCgB,EAAe,KAAK,CACnB,GAAIZ,EACJ,KAAAxB,CACD,CAAC,EAEH,CAGA,SAASgC,EACRjC,EACA2B,EACAS,EACAC,EACC,CACD,GAAM,CAAC/B,IAAOD,IAAOQ,GAAK,EAAIb,EAC9B6C,EAAK7C,EAAMsC,EAAY,CAACxB,EAAKgC,IAAkB,CAC9C,IAAMC,EAAYtC,EAAIH,EAAOQ,EAAKD,CAAK,EACjCmC,EAAQvC,EAAIJ,EAAQS,EAAKD,CAAK,EAC9BoC,EAAMH,EAAyB7B,EAAIX,EAAOQ,CAAG,EAAIS,EAAUC,EAArCC,EAC5B,GAAIsB,IAAcC,GAASC,IAAO1B,EAAS,OAC3C,IAAMtB,GAAO0B,EAAS,OAAOb,CAAU,EACvCsB,EAAQ,KACPa,IAAOxB,EACJ,CAAC,GAAAwB,EAAI,KAAAhD,EAAI,EACT,CAAC,GAAAgD,EAAI,KAAAhD,GAAM,MAAO2C,EAAwBI,CAAK,CAAC,CACpD,EACAX,EAAe,KACdY,IAAOzB,EACJ,CAAC,GAAIC,EAAQ,KAAAxB,EAAI,EACjBgD,IAAOxB,EACP,CAAC,GAAID,EAAK,KAAAvB,GAAM,MAAO2C,EAAwBG,CAAS,CAAC,EACzD,CAAC,GAAIxB,EAAS,KAAAtB,GAAM,MAAO2C,EAAwBG,CAAS,CAAC,CACjE,CACD,CAAC,CACF,CAEA,SAASZ,EACRnC,EACA2B,EACAS,EACAC,EACC,CACD,GAAI,CAAC/B,IAAOD,GAAK,EAAIL,EAEjBqB,EAAI,EACRf,EAAM,QAAS0C,GAAe,CAC7B,GAAI,CAAC3C,EAAO,IAAI2C,CAAK,EAAG,CACvB,IAAM/C,EAAO0B,EAAS,OAAO,CAACN,CAAC,CAAC,EAChCe,EAAQ,KAAK,CACZ,GAAIX,EACJ,KAAAxB,EACA,MAAA+C,CACD,CAAC,EACDX,EAAe,QAAQ,CACtB,GAAIb,EACJ,KAAAvB,EACA,MAAA+C,CACD,CAAC,EAEF3B,GACD,CAAC,EACDA,EAAI,EACJhB,EAAO,QAAS2C,GAAe,CAC9B,GAAI,CAAC1C,EAAM,IAAI0C,CAAK,EAAG,CACtB,IAAM/C,EAAO0B,EAAS,OAAO,CAACN,CAAC,CAAC,EAChCe,EAAQ,KAAK,CACZ,GAAIZ,EACJ,KAAAvB,EACA,MAAA+C,CACD,CAAC,EACDX,EAAe,QAAQ,CACtB,GAAIZ,EACJ,KAAAxB,EACA,MAAA+C,CACD,CAAC,EAEF3B,GACD,CAAC,CACF,CAEA,SAAS6B,EACRC,EACAC,EACAxB,EACO,CACP,GAAM,CAACG,IAAUC,GAAe,EAAIJ,EACpCG,EAAU,KAAK,CACd,GAAIR,EACJ,KAAM,CAAC,EACP,MAAO6B,IAAgBC,EAAU,OAAYD,CAC9C,CAAC,EACDpB,EAAiB,KAAK,CACrB,GAAIT,EACJ,KAAM,CAAC,EACP,MAAO4B,CACR,CAAC,CACF,CAEA,SAASG,EAAiBC,EAAUnB,EAA8B,CACjE,OAAAA,EAAQ,QAAQoB,GAAS,CACxB,GAAM,CAAC,KAAAvD,EAAM,GAAAgD,CAAE,EAAIO,EAEfrC,EAAYoC,EAChB,QAASlC,EAAI,EAAGA,EAAIpB,EAAK,OAAS,EAAGoB,IAAK,CACzC,IAAMoC,EAAaC,EAAYvC,CAAI,EAC/BwC,EAAI1D,EAAKoB,CAAC,EACV,OAAOsC,GAAM,UAAY,OAAOA,GAAM,WACzCA,EAAI,GAAKA,IAKRF,IAAe,GAAmBA,IAAe,KACjDE,IAAM,aAAeA,IAAMC,IAE5BC,EAAI,GAAc,CAAC,EAChBC,EAAW3C,CAAI,GAAKwC,IAAMI,GAAWF,EAAI,GAAc,CAAC,EAC5D1C,EAAOV,EAAIU,EAAMwC,CAAC,EACbrC,EAAYH,CAAI,GAAG0C,EAAI,GAAc,EAAG5D,EAAK,KAAK,GAAG,CAAC,EAG5D,IAAM+D,EAAON,EAAYvC,CAAI,EACvB6B,EAAQiB,EAAoBT,EAAM,KAAK,EACvC1C,EAAMb,EAAKA,EAAK,OAAS,CAAC,EAChC,OAAQgD,EAAI,CACX,KAAK1B,EACJ,OAAQyC,EAAM,CACb,OACC,OAAO7C,EAAK,IAAIL,EAAKkC,CAAK,EAE3B,OACCa,EAAI,EAAW,EAChB,QAKC,OAAQ1C,EAAKL,CAAG,EAAIkC,CACtB,CACD,KAAKxB,EACJ,OAAQwC,EAAM,CACb,OACC,OAAOlD,IAAQ,IACZK,EAAK,KAAK6B,CAAK,EACf7B,EAAK,OAAOL,EAAY,EAAGkC,CAAK,EACpC,OACC,OAAO7B,EAAK,IAAIL,EAAKkC,CAAK,EAC3B,OACC,OAAO7B,EAAK,IAAI6B,CAAK,EACtB,QACC,OAAQ7B,EAAKL,CAAG,EAAIkC,CACtB,CACD,KAAKvB,EACJ,OAAQuC,EAAM,CACb,OACC,OAAO7C,EAAK,OAAOL,EAAY,CAAC,EACjC,OACC,OAAOK,EAAK,OAAOL,CAAG,EACvB,OACC,OAAOK,EAAK,OAAOqC,EAAM,KAAK,EAC/B,QACC,OAAO,OAAOrC,EAAKL,CAAG,CACxB,CACD,QACC+C,EAAI,GAAc,EAAGZ,CAAE,CACzB,CACD,CAAC,EAEMM,CACR,CAMA,SAASU,EAAoBC,EAAU,CACtC,GAAI,CAACC,EAAYD,CAAG,EAAG,OAAOA,EAC9B,GAAIE,EAAQF,CAAG,EAAG,OAAOA,EAAI,IAAID,CAAmB,EACpD,GAAII,EAAMH,CAAG,EACZ,OAAO,IAAI,IACV,MAAM,KAAKA,EAAI,QAAQ,CAAC,EAAE,IAAI,CAAC,CAACI,EAAGC,CAAC,IAAM,CAACD,EAAGL,EAAoBM,CAAC,CAAC,CAAC,CACtE,EACD,GAAI3D,EAAMsD,CAAG,EAAG,OAAO,IAAI,IAAI,MAAM,KAAKA,CAAG,EAAE,IAAID,CAAmB,CAAC,EACvE,IAAMO,EAAS,OAAO,OAAOC,EAAeP,CAAG,CAAC,EAChD,QAAWpD,KAAOoD,EAAKM,EAAO1D,CAAG,EAAImD,EAAoBC,EAAIpD,CAAG,CAAC,EACjE,OAAIG,EAAIiD,EAAKQ,CAAS,IAAGF,EAAOE,CAAS,EAAIR,EAAIQ,CAAS,GACnDF,CACR,CAEA,SAAS5B,EAA2BsB,EAAW,CAC9C,OAAIS,EAAQT,CAAG,EACPD,EAAoBC,CAAG,EACjBA,CACf,CAEAU,GAAWC,EAAe,CACzBvB,IACA5B,IACAwB,IACA,QAAAnD,CACD,CAAC,CACF,CCrZO,SAAS+E,IAAe,CAC9B,MAAMC,UAAiB,GAAI,CAG1B,YAAYC,EAAgBC,EAAqB,CAChD,MAAM,EACN,KAAKC,CAAW,EAAI,CACnBC,IACAC,EAASH,EACTI,EAAQJ,EAASA,EAAOI,EAASC,EAAgB,EACjDC,EAAW,GACXC,EAAY,GACZC,EAAO,OACPC,EAAW,OACXC,EAAOX,EACPY,EAAQ,KACRC,EAAW,GACXC,EAAU,GACVC,EAAY,CAAC,CACd,CACD,CAEA,IAAI,MAAe,CAClB,OAAOC,EAAO,KAAKd,CAAW,CAAC,EAAE,IAClC,CAEA,IAAIe,EAAmB,CACtB,OAAOD,EAAO,KAAKd,CAAW,CAAC,EAAE,IAAIe,CAAG,CACzC,CAEA,IAAIA,EAAUC,EAAY,CACzB,IAAMC,EAAkB,KAAKjB,CAAW,EACxC,OAAAkB,EAAgBD,CAAK,GACjB,CAACH,EAAOG,CAAK,EAAE,IAAIF,CAAG,GAAKD,EAAOG,CAAK,EAAE,IAAIF,CAAG,IAAMC,KACzDG,EAAeF,CAAK,EACpBG,EAAYH,CAAK,EACjBA,EAAMT,EAAW,IAAIO,EAAK,EAAI,EAC9BE,EAAMV,EAAO,IAAIQ,EAAKC,CAAK,EAC3BC,EAAMT,EAAW,IAAIO,EAAK,EAAI,GAExB,IACR,CAEA,OAAOA,EAAmB,CACzB,GAAI,CAAC,KAAK,IAAIA,CAAG,EAChB,MAAO,GAGR,IAAME,EAAkB,KAAKjB,CAAW,EACxC,OAAAkB,EAAgBD,CAAK,EACrBE,EAAeF,CAAK,EACpBG,EAAYH,CAAK,EACbA,EAAMR,EAAM,IAAIM,CAAG,EACtBE,EAAMT,EAAW,IAAIO,EAAK,EAAK,EAE/BE,EAAMT,EAAW,OAAOO,CAAG,EAE5BE,EAAMV,EAAO,OAAOQ,CAAG,EAChB,EACR,CAEA,OAAQ,CACP,IAAME,EAAkB,KAAKjB,CAAW,EACxCkB,EAAgBD,CAAK,EACjBH,EAAOG,CAAK,EAAE,OACjBE,EAAeF,CAAK,EACpBG,EAAYH,CAAK,EACjBA,EAAMT,EAAY,IAAI,IACtBa,EAAKJ,EAAMR,EAAOM,GAAO,CACxBE,EAAMT,EAAW,IAAIO,EAAK,EAAK,CAChC,CAAC,EACDE,EAAMV,EAAO,MAAM,EAErB,CAEA,QAAQe,EAA+CC,EAAe,CACrE,IAAMN,EAAkB,KAAKjB,CAAW,EACxCc,EAAOG,CAAK,EAAE,QAAQ,CAACO,EAAaT,EAAUU,IAAc,CAC3DH,EAAG,KAAKC,EAAS,KAAK,IAAIR,CAAG,EAAGA,EAAK,IAAI,CAC1C,CAAC,CACF,CAEA,IAAIA,EAAe,CAClB,IAAME,EAAkB,KAAKjB,CAAW,EACxCkB,EAAgBD,CAAK,EACrB,IAAMD,EAAQF,EAAOG,CAAK,EAAE,IAAIF,CAAG,EAInC,GAHIE,EAAMX,GAAc,CAACoB,EAAYV,CAAK,GAGtCA,IAAUC,EAAMR,EAAM,IAAIM,CAAG,EAChC,OAAOC,EAGR,IAAMW,EAAQC,EAAYX,EAAMd,EAAQa,EAAOC,EAAOF,CAAG,EACzD,OAAAI,EAAeF,CAAK,EACpBA,EAAMV,EAAO,IAAIQ,EAAKY,CAAK,EACpBA,CACR,CAEA,MAA8B,CAC7B,OAAOb,EAAO,KAAKd,CAAW,CAAC,EAAE,KAAK,CACvC,CAEA,QAAgC,CAC/B,IAAM6B,EAAW,KAAK,KAAK,EAC3B,MAAO,CACN,CAAC,OAAO,QAAQ,EAAG,IAAM,KAAK,OAAO,EACrC,KAAM,IAAM,CACX,IAAMC,EAAID,EAAS,KAAK,EAExB,OAAIC,EAAE,KAAaA,EAEZ,CACN,KAAM,GACN,MAHa,KAAK,IAAIA,EAAE,KAAK,CAI9B,CACD,CACD,CACD,CAEA,SAAwC,CACvC,IAAMD,EAAW,KAAK,KAAK,EAC3B,MAAO,CACN,CAAC,OAAO,QAAQ,EAAG,IAAM,KAAK,QAAQ,EACtC,KAAM,IAAM,CACX,IAAMC,EAAID,EAAS,KAAK,EAExB,GAAIC,EAAE,KAAM,OAAOA,EACnB,IAAMd,EAAQ,KAAK,IAAIc,EAAE,KAAK,EAC9B,MAAO,CACN,KAAM,GACN,MAAO,CAACA,EAAE,MAAOd,CAAK,CACvB,CACD,CACD,CACD,CAEA,EAvIChB,EAuIA,OAAO,SAAQ,GAAI,CACnB,OAAO,KAAK,QAAQ,CACrB,CACD,CAEA,SAAS+B,EACRjC,EACAC,EACgB,CAEhB,IAAMiC,EAAM,IAAInC,EAASC,EAAQC,CAAM,EACvC,MAAO,CAACiC,EAAYA,EAAIhC,CAAW,CAAC,CACrC,CAEA,SAASmB,EAAeF,EAAiB,CACnCA,EAAMV,IACVU,EAAMT,EAAY,IAAI,IACtBS,EAAMV,EAAQ,IAAI,IAAIU,EAAMR,CAAK,EAEnC,CAEA,MAAMwB,UAAiB,GAAI,CAE1B,YAAYnC,EAAgBC,EAAqB,CAChD,MAAM,EACN,KAAKC,CAAW,EAAI,CACnBC,IACAC,EAASH,EACTI,EAAQJ,EAASA,EAAOI,EAASC,EAAgB,EACjDC,EAAW,GACXC,EAAY,GACZC,EAAO,OACPE,EAAOX,EACPY,EAAQ,KACRwB,EAAS,IAAI,IACbtB,EAAU,GACVD,EAAW,GACXH,EAAW,OACXK,EAAY,CAAC,CACd,CACD,CAEA,IAAI,MAAe,CAClB,OAAOC,EAAO,KAAKd,CAAW,CAAC,EAAE,IAClC,CAEA,IAAIgB,EAAqB,CACxB,IAAMC,EAAkB,KAAKjB,CAAW,EAGxC,OAFAkB,EAAgBD,CAAK,EAEhBA,EAAMV,EAGP,GAAAU,EAAMV,EAAM,IAAIS,CAAK,GACrBC,EAAMiB,EAAQ,IAAIlB,CAAK,GAAKC,EAAMV,EAAM,IAAIU,EAAMiB,EAAQ,IAAIlB,CAAK,CAAC,GAHhEC,EAAMR,EAAM,IAAIO,CAAK,CAM9B,CAEA,IAAIA,EAAiB,CACpB,IAAMC,EAAkB,KAAKjB,CAAW,EACxC,OAAAkB,EAAgBD,CAAK,EAChB,KAAK,IAAID,CAAK,IAClBmB,EAAelB,CAAK,EACpBG,EAAYH,CAAK,EACjBA,EAAMV,EAAO,IAAIS,CAAK,GAEhB,IACR,CAEA,OAAOA,EAAiB,CACvB,GAAI,CAAC,KAAK,IAAIA,CAAK,EAClB,MAAO,GAGR,IAAMC,EAAkB,KAAKjB,CAAW,EACxC,OAAAkB,EAAgBD,CAAK,EACrBkB,EAAelB,CAAK,EACpBG,EAAYH,CAAK,EAEhBA,EAAMV,EAAO,OAAOS,CAAK,IACxBC,EAAMiB,EAAQ,IAAIlB,CAAK,EACrBC,EAAMV,EAAO,OAAOU,EAAMiB,EAAQ,IAAIlB,CAAK,CAAC,EACjB,GAEhC,CAEA,OAAQ,CACP,IAAMC,EAAkB,KAAKjB,CAAW,EACxCkB,EAAgBD,CAAK,EACjBH,EAAOG,CAAK,EAAE,OACjBkB,EAAelB,CAAK,EACpBG,EAAYH,CAAK,EACjBA,EAAMV,EAAO,MAAM,EAErB,CAEA,QAAgC,CAC/B,IAAMU,EAAkB,KAAKjB,CAAW,EACxC,OAAAkB,EAAgBD,CAAK,EACrBkB,EAAelB,CAAK,EACbA,EAAMV,EAAO,OAAO,CAC5B,CAEA,SAAwC,CACvC,IAAMU,EAAkB,KAAKjB,CAAW,EACxC,OAAAkB,EAAgBD,CAAK,EACrBkB,EAAelB,CAAK,EACbA,EAAMV,EAAO,QAAQ,CAC7B,CAEA,MAA8B,CAC7B,OAAO,KAAK,OAAO,CACpB,CAEA,EA7FCP,EA6FA,OAAO,SAAQ,GAAI,CACnB,OAAO,KAAK,OAAO,CACpB,CAEA,QAAQsB,EAASC,EAAe,CAC/B,IAAMM,EAAW,KAAK,OAAO,EACzBO,EAASP,EAAS,KAAK,EAC3B,KAAO,CAACO,EAAO,MACdd,EAAG,KAAKC,EAASa,EAAO,MAAOA,EAAO,MAAO,IAAI,EACjDA,EAASP,EAAS,KAAK,CAEzB,CACD,CACA,SAASQ,EACRvC,EACAC,EACgB,CAEhB,IAAMuC,EAAM,IAAIL,EAASnC,EAAQC,CAAM,EACvC,MAAO,CAACuC,EAAYA,EAAItC,CAAW,CAAC,CACrC,CAEA,SAASmC,EAAelB,EAAiB,CACnCA,EAAMV,IAEVU,EAAMV,EAAQ,IAAI,IAClBU,EAAMR,EAAM,QAAQO,GAAS,CAC5B,GAAIU,EAAYV,CAAK,EAAG,CACvB,IAAMW,EAAQC,EAAYX,EAAMd,EAAQa,EAAOC,EAAOD,CAAK,EAC3DC,EAAMiB,EAAQ,IAAIlB,EAAOW,CAAK,EAC9BV,EAAMV,EAAO,IAAIoB,CAAK,OAEtBV,EAAMV,EAAO,IAAIS,CAAK,CAExB,CAAC,EAEH,CAEA,SAASE,EAAgBD,EAA+C,CACnEA,EAAML,GAAU2B,EAAI,EAAG,KAAK,UAAUzB,EAAOG,CAAK,CAAC,CAAC,CACzD,CAEA,SAASuB,EAAe1C,EAAoB,CAG3C,GAAIA,EAAOG,IAAU,GAAgBH,EAAOS,EAAO,CAClD,IAAMkC,EAAO,IAAI,IAAI3C,EAAOS,CAAK,EACjCT,EAAOS,EAAM,MAAM,EACnBkC,EAAK,QAAQzB,GAAS,CACrBlB,EAAOS,EAAO,IAAImC,GAAS1B,CAAK,CAAC,CAClC,CAAC,EAEH,CAEA2B,GAAWC,EAAc,CAACb,IAAWM,IAAW,eAAAG,CAAc,CAAC,CAChE,CX9SA,IAAMK,EAAQ,IAAIC,GAqBLC,GAAoCF,EAAM,QAM1CG,GAA0DH,EAAM,mBAAmB,KAC/FA,CACD,EAOaI,GAAgCJ,EAAM,cAAc,KAAKA,CAAK,EAO9DK,GAA0CL,EAAM,wBAAwB,KACpFA,CACD,EAQaM,GAAwCN,EAAM,sBAAsB,KAChFA,CACD,EAOaO,GAA+BP,EAAM,aAAa,KAAKA,CAAK,EAM5DQ,GAA8BR,EAAM,YAAY,KAAKA,CAAK,EAU1DS,GAA8BT,EAAM,YAAY,KAAKA,CAAK,EAQ5DU,GAAgBC,GAAuBA,EAOvCC,GAAoBD,GAA2BA","names":["immer_exports","__export","Immer","applyPatches","castDraft","castImmutable","createDraft","current","enableMapSet","enablePatches","finishDraft","freeze","DRAFTABLE","isDraft","isDraftable","NOTHING","original","produce","produceWithPatches","setAutoFreeze","setUseStrictIteration","setUseStrictShallowCopy","__toCommonJS","NOTHING","DRAFTABLE","DRAFT_STATE","die","error","args","O","getPrototypeOf","CONSTRUCTOR","PROTOTYPE","CONFIGURABLE","ENUMERABLE","WRITABLE","VALUE","isDraft","value","DRAFT_STATE","isDraftable","isPlainObject","isArray","DRAFTABLE","isMap","isSet","objectCtorString","cachedCtorStrings","isObjectish","proto","Ctor","isFunction","ctorString","original","die","base_","each","obj","iter","strict","getArchtype","key","entry","index","thing","state","type_","has","prop","type","get","set","propOrOldValue","is","x","y","target","isBoolean","getProxyDraft","latest","copy_","getValue","proxyDraft","getFinalValue","modified_","shallowCopy","base","isPlain","descriptors","keys","desc","freeze","deep","isFrozen","dontMutateMethodOverride","_key","dontMutateFrozenCollections","PluginMapSet","PluginPatches","plugins","getPlugin","pluginKey","plugin","die","isPluginLoaded","loadPlugin","implementation","currentScope","getCurrentScope","createScope","parent_","immer_","drafts_","canAutoFreeze_","unfinalizedDrafts_","handledSet_","processedForPatches_","mapSetPlugin_","isPluginLoaded","PluginMapSet","getPlugin","usePatchesInScope","scope","patchListener","patchPlugin_","PluginPatches","patches_","inversePatches_","patchListener_","revokeScope","leaveScope","revokeDraft","enterScope","immer","draft","state","DRAFT_STATE","type_","revoke_","revoked_","processResult","result","scope","unfinalizedDrafts_","drafts_","baseDraft","DRAFT_STATE","modified_","revokeScope","die","isDraftable","finalize","patchPlugin_","generateReplacementPatches_","base_","maybeFreeze","patches_","patchListener_","inversePatches_","NOTHING","rootScope","value","isFrozen","state","handleValue","handledSet_","isSameScope","finalized_","callbacks_","generatePatchesAndFinalize","copy_","deep","parent_","immer_","autoFreeze_","canAutoFreeze_","freeze","markStateFinalized","scope_","EMPTY_LOCATIONS_RESULT","updateDraftInParent","parent","draftValue","finalizedValue","originalKey","parentCopy","latest","parentType","type_","get","set","draftLocations_","draftLocations","each","key","isDraft","keys","locations","location","registerChildFinalizationCallback","child","mapSetPlugin_","getFinalValue","draft_","assigned_","basePath","generatePatches_","handleCrossReference","target","prepareCopy","targetCopy","handledSet","updatedValue","createProxyProxy","base","parent","baseIsArray","isArray","state","type_","scope_","getCurrentScope","modified_","finalized_","assigned_","parent_","base_","draft_","copy_","revoke_","isManual_","callbacks_","target","traps","objectTraps","arrayTraps","revoke","proxy","prop","DRAFT_STATE","source","latest","has","readPropFromProto","value","isDraftable","peek","prepareCopy","childKey","childDraft","createProxy","desc","getDescriptorFromProto","current","currentState","is","markChanged","handleCrossReference","owner","WRITABLE","CONFIGURABLE","ENUMERABLE","VALUE","die","getPrototypeOf","each","key","fn","args","draft","proto","shallowCopy","immer_","useStrictShallowCopy_","Immer","config","autoFreeze_","useStrictShallowCopy_","useStrictIteration_","base","recipe","patchListener","isFunction","defaultBase","self","args","draft","die","result","isDraftable","scope","enterScope","proxy","createProxy","hasError","revokeScope","leaveScope","usePatchesInScope","processResult","isObjectish","NOTHING","freeze","p","ip","getPlugin","PluginPatches","generateReplacementPatches_","patches_","inversePatches_","state","patches","inversePatches","isBoolean","isDraft","current","DRAFT_STATE","isManual_","scope_","value","i","patch","applyPatchesImpl","applyPatches_","rootScope","parent","key","isMap","PluginMapSet","proxyMap_","isSet","proxySet_","createProxyProxy","getCurrentScope","drafts_","callbacks_","key_","registerChildFinalizationCallback","mapSetPlugin_","patchPlugin_","modified_","generatePatches_","current","value","isDraft","die","currentImpl","isDraftable","isFrozen","state","DRAFT_STATE","copy","strict","modified_","base_","finalized_","shallowCopy","scope_","immer_","useStrictShallowCopy_","each","key","childValue","set","enablePatches","getPath","state","path","key_","parentCopy","parent_","copy_","base_","proxyDraft","getProxyDraft","get","valueAtKey","draft_","isSet","type_","key","setParent","drafts_","has","resolvePath","base","current","i","isObjectish","REPLACE","ADD","REMOVE","generatePatches_","basePath","scope","scope_","processedForPatches_","patches_","inversePatches_","generatePatchesFromAssigned","generateArrayPatches","generateSetPatches","patches","inversePatches","assigned_","copiedItem","baseItem","childState","DRAFT_STATE","modified_","clonePatchValueIfNeeded","each","assignedValue","origValue","value","op","generateReplacementPatches_","baseValue","replacement","NOTHING","applyPatches_","draft","patch","parentType","getArchtype","p","CONSTRUCTOR","die","isFunction","PROTOTYPE","type","deepClonePatchValue","obj","isDraftable","isArray","isMap","k","v","cloned","getPrototypeOf","DRAFTABLE","isDraft","loadPlugin","PluginPatches","enableMapSet","DraftMap","target","parent","DRAFT_STATE","type_","parent_","scope_","getCurrentScope","modified_","finalized_","copy_","assigned_","base_","draft_","isManual_","revoked_","callbacks_","latest","key","value","state","assertUnrevoked","prepareMapCopy","markChanged","each","cb","thisArg","_value","_map","isDraftable","draft","createProxy","iterator","r","proxyMap_","map","DraftSet","drafts_","prepareSetCopy","result","proxySet_","set","die","fixSetContents","copy","getValue","loadPlugin","PluginMapSet","immer","Immer","produce","produceWithPatches","setAutoFreeze","setUseStrictShallowCopy","setUseStrictIteration","applyPatches","createDraft","finishDraft","castDraft","value","castImmutable"]}